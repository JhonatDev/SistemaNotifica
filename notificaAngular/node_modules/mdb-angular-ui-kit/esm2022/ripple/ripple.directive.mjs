import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Directive, HostBinding, HostListener, Input } from '@angular/core';
import { colorToRGB, durationToMsNumber, getDiameter } from './ripple-utils';
import * as i0 from "@angular/core";
const TRANSITION_BREAK_OPACITY = 0.5;
const GRADIENT = 'rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%';
const BOOTSTRAP_COLORS = [
    'primary',
    'secondary',
    'success',
    'danger',
    'warning',
    'info',
    'light',
    'dark',
];
export class MdbRippleDirective {
    _elementRef;
    _renderer;
    get rippleCentered() {
        return this._rippleCentered;
    }
    set rippleCentered(value) {
        this._rippleCentered = coerceBooleanProperty(value);
    }
    _rippleCentered = false;
    rippleColor = '';
    rippleDuration = '500ms';
    rippleRadius = 0;
    get rippleUnbound() {
        return this._rippleUnbound;
    }
    set rippleUnbound(value) {
        this._rippleUnbound = coerceBooleanProperty(value);
    }
    _rippleUnbound = false;
    _rippleInSpan = false;
    _rippleTimer = null;
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    get host() {
        return this._elementRef.nativeElement;
    }
    ripple = true;
    _createRipple(event) {
        const { layerX, layerY } = event;
        const offsetX = layerX;
        const offsetY = layerY;
        const height = this.host.offsetHeight;
        const width = this.host.offsetWidth;
        const duration = durationToMsNumber(this.rippleDuration);
        const diameterOptions = {
            offsetX: this.rippleCentered ? height / 2 : offsetX,
            offsetY: this.rippleCentered ? width / 2 : offsetY,
            height,
            width,
        };
        const diameter = getDiameter(diameterOptions);
        const radiusValue = this.rippleRadius || diameter / 2;
        const opacity = {
            delay: duration * TRANSITION_BREAK_OPACITY,
            duration: duration - duration * TRANSITION_BREAK_OPACITY,
        };
        const styles = {
            left: this.rippleCentered ? `${width / 2 - radiusValue}px` : `${offsetX - radiusValue}px`,
            top: this.rippleCentered ? `${height / 2 - radiusValue}px` : `${offsetY - radiusValue}px`,
            height: `${this.rippleRadius * 2 || diameter}px`,
            width: `${this.rippleRadius * 2 || diameter}px`,
            transitionDelay: `0s, ${opacity.delay}ms`,
            transitionDuration: `${duration}ms, ${opacity.duration}ms`,
        };
        const rippleHTML = this._renderer.createElement('div');
        if (this.host.tagName.toLowerCase() === 'input') {
            this._createWrapperSpan();
        }
        this._createHTMLRipple(this.host, rippleHTML, styles);
        this._removeHTMLRipple(rippleHTML, duration);
    }
    _createWrapperSpan() {
        const parent = this._renderer.parentNode(this.host);
        this._rippleInSpan = true;
        if (parent.tagName.toLowerCase() === 'span' && parent.classList.contains('ripple-surface')) {
            this._elementRef.nativeElement = parent;
        }
        else {
            const wrapper = this._renderer.createElement('span');
            this._renderer.addClass(wrapper, 'ripple-surface');
            this._renderer.addClass(wrapper, 'input-wrapper');
            this._renderer.setStyle(wrapper, 'border', 0);
            const shadow = getComputedStyle(this.host).boxShadow;
            this._renderer.setStyle(wrapper, 'box-shadow', shadow);
            // Put element as child
            parent.replaceChild(wrapper, this.host);
            wrapper.appendChild(this.host);
            this._elementRef.nativeElement = wrapper;
        }
        this.host.focus();
    }
    _removeWrapperSpan() {
        const child = this.host.firstChild;
        this.host.replaceWith(child);
        this._elementRef.nativeElement = child;
        this.host.focus();
        this._rippleInSpan = false;
    }
    _createHTMLRipple(wrapper, ripple, styles) {
        Object.keys(styles).forEach((property) => (ripple.style[property] = styles[property]));
        this._renderer.addClass(ripple, 'ripple-wave');
        if (this.rippleColor !== '') {
            this._removeOldColorClasses(wrapper);
            this._addColor(ripple, wrapper);
        }
        this._toggleUnbound(wrapper);
        this._appendRipple(ripple, wrapper);
    }
    _removeHTMLRipple(ripple, duration) {
        if (this._rippleTimer) {
            clearTimeout(this._rippleTimer);
            this._rippleTimer = null;
        }
        this._rippleTimer = setTimeout(() => {
            if (ripple) {
                ripple.remove();
                this.host.querySelectorAll('.ripple-wave').forEach((rippleEl) => {
                    rippleEl.remove();
                });
                if (this._rippleInSpan && this.host.classList.contains('input-wrapper')) {
                    this._removeWrapperSpan();
                }
            }
        }, duration);
    }
    _appendRipple(target, parent) {
        const FIX_ADD_RIPPLE_EFFECT = 50; // delay for active animations
        this._renderer.appendChild(parent, target);
        setTimeout(() => {
            this._renderer.addClass(target, 'active');
        }, FIX_ADD_RIPPLE_EFFECT);
    }
    _toggleUnbound(target) {
        if (this.rippleUnbound) {
            this._renderer.addClass(target, 'ripple-surface-unbound');
        }
        else {
            this._renderer.removeClass(target, 'ripple-surface-unbound');
        }
    }
    _addColor(target, parent) {
        const isBootstrapColor = BOOTSTRAP_COLORS.find((color) => color === this.rippleColor.toLowerCase());
        if (isBootstrapColor) {
            this._renderer.addClass(parent, `${'ripple-surface'}-${this.rippleColor.toLowerCase()}`);
        }
        else {
            const rgbValue = colorToRGB(this.rippleColor).join(',');
            const gradientImage = GRADIENT.split('{{color}}').join(`${rgbValue}`);
            target.style.backgroundImage = `radial-gradient(circle, ${gradientImage})`;
        }
    }
    _removeOldColorClasses(target) {
        const REGEXP_CLASS_COLOR = new RegExp(`${'ripple-surface'}-[a-z]+`, 'gi');
        const PARENT_CLASSS_COLOR = target.classList.value.match(REGEXP_CLASS_COLOR) || [];
        PARENT_CLASSS_COLOR.forEach((className) => {
            this._renderer.removeClass(target, className);
        });
    }
    static ngAcceptInputType_rippleCentered;
    static ngAcceptInputType_rippleUnbound;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: MdbRippleDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: MdbRippleDirective, selector: "[mdbRipple]", inputs: { rippleCentered: "rippleCentered", rippleColor: "rippleColor", rippleDuration: "rippleDuration", rippleRadius: "rippleRadius", rippleUnbound: "rippleUnbound" }, host: { listeners: { "click": "_createRipple($event)" }, properties: { "class.ripple-surface": "this.ripple" } }, exportAs: ["mdbRipple"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: MdbRippleDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[mdbRipple]',
                    exportAs: 'mdbRipple',
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { rippleCentered: [{
                type: Input
            }], rippleColor: [{
                type: Input
            }], rippleDuration: [{
                type: Input
            }], rippleRadius: [{
                type: Input
            }], rippleUnbound: [{
                type: Input
            }], ripple: [{
                type: HostBinding,
                args: ['class.ripple-surface']
            }], _createRipple: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmlwcGxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL21kYi1hbmd1bGFyLXVpLWtpdC9yaXBwbGUvcmlwcGxlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFNBQVMsRUFBYyxXQUFXLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNuRyxPQUFPLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUU3RSxNQUFNLHdCQUF3QixHQUFHLEdBQUcsQ0FBQztBQUVyQyxNQUFNLFFBQVEsR0FDWiw4SEFBOEgsQ0FBQztBQUNqSSxNQUFNLGdCQUFnQixHQUFHO0lBQ3ZCLFNBQVM7SUFDVCxXQUFXO0lBQ1gsU0FBUztJQUNULFFBQVE7SUFDUixTQUFTO0lBQ1QsTUFBTTtJQUNOLE9BQU87SUFDUCxNQUFNO0NBQ1AsQ0FBQztBQU9GLE1BQU0sT0FBTyxrQkFBa0I7SUEyQlQ7SUFBaUM7SUExQnJELElBQ0ksY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDOUIsQ0FBQztJQUNELElBQUksY0FBYyxDQUFDLEtBQWM7UUFDL0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBQ08sZUFBZSxHQUFHLEtBQUssQ0FBQztJQUV2QixXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLGNBQWMsR0FBRyxPQUFPLENBQUM7SUFDekIsWUFBWSxHQUFHLENBQUMsQ0FBQztJQUUxQixJQUNJLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDN0IsQ0FBQztJQUNELElBQUksYUFBYSxDQUFDLEtBQWM7UUFDOUIsSUFB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RTtZQUN4QyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDaEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsTUFBTSxDQUFDLGdDQUFnQyxDQUFlO0lBQ3RELE1BQU0sQ0FBQywrQkFBK0IsQ0FBZTt1R0FsTDFDLGtCQUFrQjsyRkFBbEIsa0JBQWtCOzsyRkFBbEIsa0JBQWtCO2tCQUw5QixTQUFTO21CQUFDO29CQUNULDhEQUE4RDtvQkFDOUQsUUFBUSxFQUFFLGFBQWE7b0JBQ3ZCLFFBQVEsRUFBRSxXQUFXO2lCQUN0Qjt1R0FHSyxjQUFjO3NCQURqQixLQUFLO2dCQVNHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBQ0csY0FBYztzQkFBdEIsS0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLO2dCQUdGLGFBQWE7c0JBRGhCLEtBQUs7Z0JBbUIrQixNQUFNO3NCQUExQyxXQUFXO3VCQUFDLHNCQUFzQjtnQkFHbkMsYUFBYTtzQkFEWixZQUFZO3VCQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29sb3JUb1JHQiwgZHVyYXRpb25Ub01zTnVtYmVyLCBnZXREaWFtZXRlciB9IGZyb20gJy4vcmlwcGxlLXV0aWxzJztcblxuY29uc3QgVFJBTlNJVElPTl9CUkVBS19PUEFDSVRZID0gMC41O1xuXG5jb25zdCBHUkFESUVOVCA9XG4gICdyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlJztcbmNvbnN0IEJPT1RTVFJBUF9DT0xPUlMgPSBbXG4gICdwcmltYXJ5JyxcbiAgJ3NlY29uZGFyeScsXG4gICdzdWNjZXNzJyxcbiAgJ2RhbmdlcicsXG4gICd3YXJuaW5nJyxcbiAgJ2luZm8nLFxuICAnbGlnaHQnLFxuICAnZGFyaycsXG5dO1xuXG5ARGlyZWN0aXZlKHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9kaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdbbWRiUmlwcGxlXScsXG4gIGV4cG9ydEFzOiAnbWRiUmlwcGxlJyxcbn0pXG5leHBvcnQgY2xhc3MgTWRiUmlwcGxlRGlyZWN0aXZlIHtcbiAgQElucHV0KClcbiAgZ2V0IHJpcHBsZUNlbnRlcmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9yaXBwbGVDZW50ZXJlZDtcbiAgfVxuICBzZXQgcmlwcGxlQ2VudGVyZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yaXBwbGVDZW50ZXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfcmlwcGxlQ2VudGVyZWQgPSBmYWxzZTtcblxuICBASW5wdXQoKSByaXBwbGVDb2xvciA9ICcnO1xuICBASW5wdXQoKSByaXBwbGVEdXJhdGlvbiA9ICc1MDBtcyc7XG4gIEBJbnB1dCgpIHJpcHBsZVJhZGl1cyA9IDA7XG5cbiAgQElucHV0KClcbiAgZ2V0IHJpcHBsZVVuYm91bmQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3JpcHBsZVVuYm91bmQ7XG4gIH1cbiAgc2V0IHJpcHBsZVVuYm91bmQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yaXBwbGVVbmJvdW5kID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9yaXBwbGVVbmJvdW5kID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfcmlwcGxlSW5TcGFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfcmlwcGxlVGltZXIgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgZ2V0IGhvc3QoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnJpcHBsZS1zdXJmYWNlJykgcmlwcGxlID0gdHJ1ZTtcblxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gIF9jcmVhdGVSaXBwbGUoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHsgbGF5ZXJYLCBsYXllclkgfSA9IGV2ZW50O1xuICAgIGNvbnN0IG9mZnNldFggPSBsYXllclg7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGxheWVyWTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhvc3Qub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5ob3N0Lm9mZnNldFdpZHRoO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZHVyYXRpb25Ub01zTnVtYmVyKHRoaXMucmlwcGxlRHVyYXRpb24pO1xuICAgIGNvbnN0IGRpYW1ldGVyT3B0aW9ucyA9IHtcbiAgICAgIG9mZnNldFg6IHRoaXMucmlwcGxlQ2VudGVyZWQgPyBoZWlnaHQgLyAyIDogb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IHRoaXMucmlwcGxlQ2VudGVyZWQgPyB3aWR0aCAvIDIgOiBvZmZzZXRZLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgfTtcbiAgICBjb25zdCBkaWFtZXRlciA9IGdldERpYW1ldGVyKGRpYW1ldGVyT3B0aW9ucyk7XG4gICAgY29uc3QgcmFkaXVzVmFsdWUgPSB0aGlzLnJpcHBsZVJhZGl1cyB8fCBkaWFtZXRlciAvIDI7XG5cbiAgICBjb25zdCBvcGFjaXR5ID0ge1xuICAgICAgZGVsYXk6IGR1cmF0aW9uICogVFJBTlNJVElPTl9CUkVBS19PUEFDSVRZLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC0gZHVyYXRpb24gKiBUUkFOU0lUSU9OX0JSRUFLX09QQUNJVFksXG4gICAgfTtcblxuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIGxlZnQ6IHRoaXMucmlwcGxlQ2VudGVyZWQgPyBgJHt3aWR0aCAvIDIgLSByYWRpdXNWYWx1ZX1weGAgOiBgJHtvZmZzZXRYIC0gcmFkaXVzVmFsdWV9cHhgLFxuICAgICAgdG9wOiB0aGlzLnJpcHBsZUNlbnRlcmVkID8gYCR7aGVpZ2h0IC8gMiAtIHJhZGl1c1ZhbHVlfXB4YCA6IGAke29mZnNldFkgLSByYWRpdXNWYWx1ZX1weGAsXG4gICAgICBoZWlnaHQ6IGAke3RoaXMucmlwcGxlUmFkaXVzICogMiB8fCBkaWFtZXRlcn1weGAsXG4gICAgICB3aWR0aDogYCR7dGhpcy5yaXBwbGVSYWRpdXMgKiAyIHx8IGRpYW1ldGVyfXB4YCxcbiAgICAgIHRyYW5zaXRpb25EZWxheTogYDBzLCAke29wYWNpdHkuZGVsYXl9bXNgLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtkdXJhdGlvbn1tcywgJHtvcGFjaXR5LmR1cmF0aW9ufW1zYCxcbiAgICB9O1xuXG4gICAgY29uc3QgcmlwcGxlSFRNTCA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgaWYgKHRoaXMuaG9zdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVdyYXBwZXJTcGFuKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlSFRNTFJpcHBsZSh0aGlzLmhvc3QsIHJpcHBsZUhUTUwsIHN0eWxlcyk7XG4gICAgdGhpcy5fcmVtb3ZlSFRNTFJpcHBsZShyaXBwbGVIVE1MLCBkdXJhdGlvbik7XG4gIH1cblxuICBwcml2YXRlIF9jcmVhdGVXcmFwcGVyU3BhbigpOiB2b2lkIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9yZW5kZXJlci5wYXJlbnROb2RlKHRoaXMuaG9zdCk7XG4gICAgdGhpcy5fcmlwcGxlSW5TcGFuID0gdHJ1ZTtcbiAgICBpZiAocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nICYmIHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3JpcHBsZS1zdXJmYWNlJykpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCA9IHBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3Mod3JhcHBlciwgJ3JpcHBsZS1zdXJmYWNlJyk7XG4gICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh3cmFwcGVyLCAnaW5wdXQtd3JhcHBlcicpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh3cmFwcGVyLCAnYm9yZGVyJywgMCk7XG5cbiAgICAgIGNvbnN0IHNoYWRvdyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5ob3N0KS5ib3hTaGFkb3c7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh3cmFwcGVyLCAnYm94LXNoYWRvdycsIHNoYWRvdyk7XG5cbiAgICAgIC8vIFB1dCBlbGVtZW50IGFzIGNoaWxkXG4gICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHdyYXBwZXIsIHRoaXMuaG9zdCk7XG4gICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuaG9zdCk7XG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgPSB3cmFwcGVyO1xuICAgIH1cbiAgICB0aGlzLmhvc3QuZm9jdXMoKTtcbiAgfVxuXG4gIF9yZW1vdmVXcmFwcGVyU3BhbigpIHtcbiAgICBjb25zdCBjaGlsZCA9IHRoaXMuaG9zdC5maXJzdENoaWxkO1xuICAgIHRoaXMuaG9zdC5yZXBsYWNlV2l0aChjaGlsZCk7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ID0gY2hpbGQ7XG4gICAgdGhpcy5ob3N0LmZvY3VzKCk7XG4gICAgdGhpcy5fcmlwcGxlSW5TcGFuID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9jcmVhdGVIVE1MUmlwcGxlKHdyYXBwZXI6IEhUTUxFbGVtZW50LCByaXBwbGU6IEhUTUxFbGVtZW50LCBzdHlsZXM6IGFueSk6IHZvaWQge1xuICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaCgocHJvcGVydHkpID0+IChyaXBwbGUuc3R5bGVbcHJvcGVydHldID0gc3R5bGVzW3Byb3BlcnR5XSkpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHJpcHBsZSwgJ3JpcHBsZS13YXZlJyk7XG5cbiAgICBpZiAodGhpcy5yaXBwbGVDb2xvciAhPT0gJycpIHtcbiAgICAgIHRoaXMuX3JlbW92ZU9sZENvbG9yQ2xhc3Nlcyh3cmFwcGVyKTtcbiAgICAgIHRoaXMuX2FkZENvbG9yKHJpcHBsZSwgd3JhcHBlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fdG9nZ2xlVW5ib3VuZCh3cmFwcGVyKTtcbiAgICB0aGlzLl9hcHBlbmRSaXBwbGUocmlwcGxlLCB3cmFwcGVyKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlbW92ZUhUTUxSaXBwbGUocmlwcGxlOiBIVE1MRWxlbWVudCwgZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9yaXBwbGVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JpcHBsZVRpbWVyKTtcbiAgICAgIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcmlwcGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChyaXBwbGUpIHtcbiAgICAgICAgcmlwcGxlLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmhvc3QucXVlcnlTZWxlY3RvckFsbCgnLnJpcHBsZS13YXZlJykuZm9yRWFjaCgocmlwcGxlRWwpID0+IHtcbiAgICAgICAgICByaXBwbGVFbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9yaXBwbGVJblNwYW4gJiYgdGhpcy5ob3N0LmNsYXNzTGlzdC5jb250YWlucygnaW5wdXQtd3JhcHBlcicpKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlV3JhcHBlclNwYW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGR1cmF0aW9uKTtcbiAgfVxuXG4gIF9hcHBlbmRSaXBwbGUodGFyZ2V0OiBIVE1MRWxlbWVudCwgcGFyZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIGNvbnN0IEZJWF9BRERfUklQUExFX0VGRkVDVCA9IDUwOyAvLyBkZWxheSBmb3IgYWN0aXZlIGFuaW1hdGlvbnNcbiAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZChwYXJlbnQsIHRhcmdldCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0YXJnZXQsICdhY3RpdmUnKTtcbiAgICB9LCBGSVhfQUREX1JJUFBMRV9FRkZFQ1QpO1xuICB9XG5cbiAgX3RvZ2dsZVVuYm91bmQodGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJpcHBsZVVuYm91bmQpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRhcmdldCwgJ3JpcHBsZS1zdXJmYWNlLXVuYm91bmQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGFyZ2V0LCAncmlwcGxlLXN1cmZhY2UtdW5ib3VuZCcpO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRDb2xvcih0YXJnZXQ6IEhUTUxFbGVtZW50LCBwYXJlbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgY29uc3QgaXNCb290c3RyYXBDb2xvciA9IEJPT1RTVFJBUF9DT0xPUlMuZmluZChcbiAgICAgIChjb2xvcikgPT4gY29sb3IgPT09IHRoaXMucmlwcGxlQ29sb3IudG9Mb3dlckNhc2UoKVxuICAgICk7XG5cbiAgICBpZiAoaXNCb290c3RyYXBDb2xvcikge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MocGFyZW50LCBgJHsncmlwcGxlLXN1cmZhY2UnfS0ke3RoaXMucmlwcGxlQ29sb3IudG9Mb3dlckNhc2UoKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmdiVmFsdWUgPSBjb2xvclRvUkdCKHRoaXMucmlwcGxlQ29sb3IpLmpvaW4oJywnKTtcbiAgICAgIGNvbnN0IGdyYWRpZW50SW1hZ2UgPSBHUkFESUVOVC5zcGxpdCgne3tjb2xvcn19Jykuam9pbihgJHtyZ2JWYWx1ZX1gKTtcbiAgICAgIHRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgcmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgJHtncmFkaWVudEltYWdlfSlgO1xuICAgIH1cbiAgfVxuXG4gIF9yZW1vdmVPbGRDb2xvckNsYXNzZXModGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIGNvbnN0IFJFR0VYUF9DTEFTU19DT0xPUiA9IG5ldyBSZWdFeHAoYCR7J3JpcHBsZS1zdXJmYWNlJ30tW2Etel0rYCwgJ2dpJyk7XG4gICAgY29uc3QgUEFSRU5UX0NMQVNTU19DT0xPUiA9IHRhcmdldC5jbGFzc0xpc3QudmFsdWUubWF0Y2goUkVHRVhQX0NMQVNTX0NPTE9SKSB8fCBbXTtcbiAgICBQQVJFTlRfQ0xBU1NTX0NPTE9SLmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGFyZ2V0LCBjbGFzc05hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3JpcHBsZUNlbnRlcmVkOiBCb29sZWFuSW5wdXQ7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yaXBwbGVVbmJvdW5kOiBCb29sZWFuSW5wdXQ7XG59XG4iXX0=